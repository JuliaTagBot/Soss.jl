<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear model · Soss.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Soss.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Linear model</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../to-do-list/">To-Do List</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Linear model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cscherrer/Soss.jl/blob/master/examples/example-linear-model.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example:-Linear-Model"><a class="docs-heading-anchor" href="#Example:-Linear-Model">Example: Linear Model</a><a id="Example:-Linear-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Linear-Model" title="Permalink"></a></h1><p>Let&#39;s jump right in with a simple linear model:</p><pre><code class="language-julia">using Soss

m = @model X begin
    β ~ Normal() |&gt; iid(size(X,2))
    y ~ For(eachrow(X)) do x
        Normal(x&#39; * β, 1)
    end
end</code></pre><pre class="documenter-example-output">@model X begin
        β ~ Normal() |&gt; iid(size(X, 2))
        y ~ For(eachrow(X)) do x
                Normal(x&#39; * β, 1)
            end
    end
</pre><p>In Soss, models are <em>first-class</em> and <em>function-like</em>, and applying a model to its arguments gives a <em>joint distribution</em>.</p><p>Just a few of the things we can do in Soss:</p><ul><li>Sample from the (forward) model</li><li>Condition a joint distribution on a subset of parameters</li><li>Have arbitrary Julia values (yes, even other models) as inputs or outputs of a model</li><li>Build a new model for the <em>predictive</em> distribution, for assigning parameters to particular values</li></ul><p>Let&#39;s use our model to build some fake data:</p><pre><code class="language-julia">import Random

Random.seed!(3)
X = randn(6,2)
truth = rand(m(X=X))
pairs(truth)</code></pre><pre class="documenter-example-output">pairs(::NamedTuple) with 2 entries:
  :β =&gt; [0.0718727, -0.51281]
  :y =&gt; [-1.54629, 0.331571, -1.07547, -1.66897, -1.03357, -0.576155]</pre><p>Look at the true coefficients:</p><pre><code class="language-julia">truth.β</code></pre><pre class="documenter-example-output">2-element Array{Float64,1}:
  0.07187269298745927
 -0.5128103336795292</pre><p>Look at the true labels:</p><pre><code class="language-julia">truth.y</code></pre><pre class="documenter-example-output">6-element Array{Float64,1}:
 -1.5462858466884173
  0.33157118320250245
 -1.07546820508531
 -1.6689735918627429
 -1.0335681260821046
 -0.5761553015966487</pre><p>And now pretend we don&#39;t know <code>β</code>, and have the model figure it out.</p><pre><code class="language-julia">post = dynamicHMC(m(X=X), (y=truth.y,))</code></pre><pre class="documenter-example-output">1000-element Array{NamedTuple{(:β,),Tuple{Array{Float64,1}}},1}:
 (β = [0.20409988733534754, -1.01867552189848],)
 (β = [0.10106630247717097, -0.7494142948039466],)
 (β = [-0.138319627899054, -0.36159991654298423],)
 (β = [0.3105209880513822, -1.6090416251219788],)
 (β = [-0.13805713169775496, -0.9701497626140632],)
 (β = [0.12050989043494814, -0.7885707464526038],)
 (β = [-0.15664947720253414, -0.6573135582173841],)
 (β = [-0.42789225662841907, -1.0496819817876257],)
 (β = [-0.28396888149100596, -0.9780544278380506],)
 (β = [0.021974008994914862, -0.19812982922559214],)
 ⋮
 (β = [0.13653109358657714, -0.47631912806837207],)
 (β = [-0.3208972832298396, -1.054015046592049],)
 (β = [0.09909298312926401, -0.4488680864432285],)
 (β = [-0.14876052437118045, -0.920579800082227],)
 (β = [-0.34149209191540336, -0.739296121217693],)
 (β = [0.1035064485555062, -0.45535756632260177],)
 (β = [-0.14851675100659356, -0.33376910993471964],)
 (β = [-0.01108288292338655, -0.7075473023399144],)
 (β = [0.11182874588674081, -1.4766090812408703],)</pre><p>Often these are easier to work with in terms of <code>particles</code> (built using <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a>):</p><pre><code class="language-julia">particles(post)</code></pre><pre class="documenter-example-output">(β = Particles{Float64,1000}[-0.0484 ± 0.26, -0.793 ± 0.52],)</pre><p>For model diagnostics and prediction, we need the <em>predictive distribution</em>:</p><pre><code class="language-julia">pred = predictive(m,:β)</code></pre><pre class="documenter-example-output">@model (X, β) begin
        y ~ For(eachrow(X)) do x
                Normal(x&#39; * β, 1)
            end
    end
</pre><p>This requires <code>X</code> and <code>β</code> as inputs, so we can do something like this to do a <em>posterior predictive check</em></p><pre><code class="language-julia">ppc = [rand(pred(;X=X, p...)).y for p in post]
truth.y - particles(ppc)</code></pre><pre class="documenter-example-output">6-element Array{Particles{Float64,1000},1}:
 -1.35 ± 1.0
  0.252 ± 1.2
 -0.202 ± 1.2
 -1.05 ± 1.2
 -0.104 ± 1.2
 -0.998 ± 1.1</pre><p>These play a role similar to that of residuals in a non-Bayesian approach (there&#39;s plenty more detail to go into, but that&#39;s for another time).</p><p>With some minor modifications, we can put this into a form that allows symbolic simplification: [the <code>evalf(3)</code> is to reduce the displayed number of decimal positions]</p><p>m2 = @model X begin     N = size(X,1)     k = size(X,2)     β ~ Normal() |&gt; iid(k)     yhat = X * β     y ~ For(N) do j             Normal(yhat[j], 1)         end end;</p><p>symlogpdf(m2).evalf(3)</p><p>We can use the symbolic simplification to speed up computations:</p><p>using BenchmarkTools</p><p>jointdist = m2(X=X)</p><p>@model X begin     k = size(X, 2)     β ~ Normal() |&gt; iid(k)     yhat = X * β     N = size(X, 1)     y ~ For(N) do j         Normal(yhat[j], 1)     end end</p><p>Without symbolic simplification:</p><p>@btime logpdf(jointdist, truth)</p><p>With symbolic simplification:</p><p>@btime logpdf(jointdist, truth, codegen)</p><p>What&#39;s Really Happening Here?</p><p>Under the hood, <code>rand</code> and <code>logpdf</code> specify different ways of &quot;running&quot; the model.</p><p><code>rand</code>  turns each <code>v ~ dist</code> into <code>v = rand(dist)</code>, finally outputting the <code>NamedTuple</code> of all values it has seen.</p><p><code>logpdf</code> steps through the same program, but instead accumulates a log-density. It begins by initializing <code>_ℓ = 0.0</code>. Then at each step, it turns <code>v ~ dist</code> into <code>_ℓ += logpdf(dist, v)</code>, before finally returning <code>_ℓ</code>.</p><p>Note that I said &quot;turns into&quot; instead of &quot;interprets&quot;. Soss uses <a href="https://github.com/thautwarm/GG.jl"><code>GG.jl</code></a> to generate specialized code for a given model, inference primitive (like <code>rand</code> and <code>logpdf</code>), and type of data.</p><p>This idea can be used in much more complex ways. <code>weightedSample</code> is a sort of hybrid between <code>rand</code> and <code>logpdf</code>. For data that are provided, it increments a <code>_ℓ</code> using <code>logpdf</code>. Unknown values are sampled using <code>rand</code>.</p><pre><code class="language-julia">ℓ, proposal = weightedSample(m(X=X), (y=truth.y,));</code></pre><p><code>ℓ</code>:</p><pre><code class="language-julia">ℓ</code></pre><pre class="documenter-example-output">-10.094135139337315</pre><p><code>proposal.β</code>:</p><pre><code class="language-julia">proposal.β</code></pre><pre class="documenter-example-output">2-element Array{Float64,1}:
 -0.6118607888077296
 -0.6489424142398419</pre><p>Again, there&#39;s no runtime check needed for this. Each of these is compiled the first time it is called, so future calls are very fast. Functions like this are great to use in tight loops.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 September 2020 07:30">Friday 4 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
